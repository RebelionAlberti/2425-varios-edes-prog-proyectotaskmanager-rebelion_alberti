# 4.3.2 Aplicación de Code Smells y Patrones de Refactorización en el Código del TaskManager:

## code Smells encontrados:

### 1. Large Class (Clase larga)

La clase `ActividadService` contiene múltiples métodos con lógica diversa y está a cargo de muchas responsabilidades
diferentes. Incumple el SRP.

El patrón de diseño más adecuado, en teoría, sería el Factory Method / Abstract Factory: Para la creación de diferentes 
tipos de actividades (Tarea, Evento), usamos un patrón Factory para encapsular la lógica de creación fuera del servicio.

#### solución dada:

Para arreglar que la clase fuese tan larga, moví la creación de tareas y eventos a una fábrica (Factory Method). Así, el 
servicio solo se encarga de gestionar y no de crear objetos, dejando el código más limpio y fácil de mantener.

### 2.  Feature Envy (Envidia de función)

En la clase `ActividadService` hay partes donde el servicio accede y modifica directamente el estado interno de objetos.

El patrón más adecuado sería el patrón de diseño Command, que crea comandos para encapsular las operaciones de
cambio de estado o asignación, para que la lógica de negocio quede encapsulada en esos objetos comando.


#### solución dada:

Para evitar que la clase se meta mucho en los detalles de cómo cambiar el estado de una tarea, usé el patrón Command. 
Esto significa que la lógica de cambiar estados va en objetos aparte (comandos), y el servicio solo los ejecuta.
Así el código queda más limpio y fácil de entender.

Enlace al [commit de los 2 primeros codeSmells arreglados](https://github.com/RebelionAlberti/2425-varios-edes-prog-proyectotaskmanager-rebelion_alberti/commit/ea9d5666badc08c3c7819a6c84a374713ec9c7a8)
después de aplicar los patrones de diseño.

### 3. Duplicate code (código duplicado)

La clase `UsuarioService` tiene varios métodos con código muy pero que muy similar, llamando a métodos del repositorio 
sin ningún cambio. Esto se convierte en código duplicado o innecesario.

El patrón de refactorización más adecuado para solucionar esto es **Extract Method**, porque permite extraer el código repetido 
en un método separado, dándole un nombre descriptivo, y luego reutilizar ese método en los lugares donde aparecía el 
código duplicado.

Enlace al [commit 1 codeSmell + arreglo](https://github.com/RebelionAlberti/2425-varios-edes-prog-proyectotaskmanager-rebelion_alberti/commit/1326f42ea10cd1f5e5d2fc01fd16cb7d31c9c7b9) 
después de aplicarle la solución.

### 4. Inappropriate Intimacy (Intimidad inapropiada)

La clase `UsuarioService` depende directamente de la clase `Usuario.crear(nombre)` para construir instancias. Si 
`Usuario.crear` cambia internamente, el servicio puede verse afectado.

El patrón de refactorización más adecuado para este codeSmell es **Replace Constructor with Factory Method** porque
encapsula la creación del objeto en una clase dedicada, evitando que UsuarioService conozca los detalles internos de 
cómo se crea un Usuario. Esto reduce el acoplamiento entre clases, mejora la responsabilidad única (SRP) y facilita 
cambios futuros sin afectar al servicio.

Enlace al [commit 4to codeSmell solucionado](https://github.com/RebelionAlberti/2425-varios-edes-prog-proyectotaskmanager-rebelion_alberti/commit/baee28185226c0020b250d35f9459e928f34b319) 
después de aplicarle la solución.

#### 5. Switch Statements (Sentencias switch)

En la clase `ActividadRepository` se concentra mucha lógica en un solo lugar, rompe la extensibilidad y dificulta mantener
y escalar el código. Es mejor usar polimorfismo para distribuir responsabilidades. Aunque no hay un when o switch explícito,
este trozo de código funciona como uno de forma implícita: 

```kotlin
override fun asignarUsuarioATarea(idTarea: Int, usuario: Usuario?): Boolean { 
    val actividad = actividades.find { it.id == idTarea }
    if (actividad is Tarea) { 
        actividad.asignadoA = usuario
        return true
    }
    return false
}
```

El mejor refactoring para aplicar es Replace Conditional with Polymorphism, mueve la lógica de asignación de usuario 
al interior de las clases que la llevan (clase Tarea). 

Se ha movido la lógica de asignar usuario desde ActividadRepository a la clase Tarea, eliminando el if con is Tarea. En Tarea,
añadimos un método como asignarUsuario(), y en ActividadRepository, simplemente llamamos a ese método. Esto elimina el 
acoplamiento al tipo y hace el código más limpio y fácil de mantener. De esta manera

Enlace al [commit quinto codeSmell arreglado](https://github.com/RebelionAlberti/2425-varios-edes-prog-proyectotaskmanager-rebelion_alberti/commit/77046d3df482b599c3e4e16a280928a758375bc6) 
después de aplicarle la solución.